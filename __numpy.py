# -*- coding: utf-8 -*-
import numpy as np

"""
NumPy
----------

多维同构数组和矩阵
"""

########################################################################
###  生成
########################################################################
def fun1():

    np.array([1] * 3)
    # array([1, 1, 1])
    np.array([[1, 2]] * 3)
    # array([[1, 2], [1, 2], [1, 2]])

    np.arange(10)
    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    np.arange(0, 10, 2)
    # array([0, 2, 4, 6, 8])
    np.arange(0, 5, 0.5)
    # array([0., 0.5, 1., 1.5, 2., 2.5, 3., 3.5, 4., 4.5])

    np.ones((1, 3))
    # array([[1., 1., 1.]])
    np.ones((2, 3))
    # array([[1., 1., 1.], [1., 1., 1.]])

    np.zeros((1, 3))
    # array([[0., 0., 0.]])

    np.tile((1, 0), (3, 2))
    # array([[1, 0, 1, 0], [1, 0, 1, 0], [1, 0, 1, 0]])

    np.repeat([1,2,3],3)
    # array([1, 1, 1, 2, 2, 2, 3, 3, 3])
    np.repeat([[1, 2, 3]], 3)
    # array([[1, 1, 1, 2, 2, 2, 3, 3, 3]])
    np.repeat([[1, 2, 3]], 3, axis=0)
    # array([[1, 2, 3], [1, 2, 3], [1, 2, 3]])

    # 返回元素未初始化的数组
    np.empty((2, 3))
    # array([[19., 0., 2.], [0., 2., 0.]])

    # [0, 1]范围内的随机数
    np.random.rand(3)
    # array([0.43742439, 0.74414248, 0.64773594])
    np.random.rand(2,3)
    # array([[0.63363191, 0.47820523, 0.49097646], [0.83589059, 0.81589082, 0.66916447]])

    # 服从0均值、1方差正太分布的随机值
    np.random.randn(2, 3)
    # array([[-2.02216373, 0.26326303, -0.75350819], [0.68184794, 1.25350384, 1.65132566]])

    # 服从1均值、2方差正太分布的随机值
    np.random.normal(1, 2, (2, 3))
    # array([[0.45447811, 4.10102255, 0.33016492], [0.06254273, -2.51800279, -2.59551469]])

    # 生成指定范围内的随机浮点数
    np.random.uniform(0, 100, size=2)
    # array([72.09771968, 87.02382082])

    # 生成指定范围内的随机整数(可能重复)
    np.random.randint(0, 100, size=2)
    #  array([35, 42])


########################################################################
###  属性
########################################################################
def fun2():

    arr1 = np.arange(10)
    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

    # 改变数据形状（浅复制）
    arr2 = np.arange(10).reshape((2,5))
    # array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])

    shape1 = arr1.shape
    # tuple(10,)
    shape2 = arr2.shape
    # tuple(2, 5)

    size = arr2.size
    # 10

    dtype = arr2.dtype
    # dtype(int32)

    ndim = arr2.ndim
    # 2

    arr1.astype(dtype='str', copy=True)
    # array(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], dtype='<U11')


########################################################################
###  重塑/排序
########################################################################
def fun3():

    arr1 = np.arange(10)
    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

    arr_1 = arr_2 = np.arange(5)
    # array([0, 1, 2, 3, 4])
    arr_1 = np.array([1,2,3])   # 重新分配指向, 此时arr_1和arr_2指向不同内存空间
    # arr_1 : array([1, 2, 3])
    # arr_2 : array([0, 1, 2, 3, 4])

    # 自定义数据形状（浅复制）
    arr2 = arr1.reshape((2,5))
    # array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])

    # 扁平化数组（深复制）
    arr2.flatten()
    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

    # 扁平化数组（浅复制）
    arr2.ravel('C')     # 按行展开
    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    arr2.ravel('F')     # 按列展开
    # array([0, 5, 1, 6, 2, 7, 3, 8, 4, 9])

    # 转置（浅复制）
    arr1.transpose()    # 一维数组转置是其本身
    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    arr2.transpose()
    # array([[0, 5], [1, 6], [2, 7], [3, 8], [4, 9]])


########################################################################
###  合并/拆分
########################################################################
def fun4():

    arr1 = np.array([[1,2,3], [4,5,6]])
    # array([[1, 2, 3], [4, 5, 6]])
    arr2 = arr1 + 6
    # array([[7, 8, 9], [10, 11, 12]])

    # 数组拼接（深复制）
    np.concatenate((arr1, arr2))
    # array([[ 1,  2,  3], [ 4,  5,  6], [ 7,  8,  9], [10, 11, 12]])
    np.concatenate((arr1, arr2), axis=1)
    # array([[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]])

    # 数组拼接（深复制）, 垂直/水平方向
    np.vstack((arr1, arr2))
    # array([[ 1,  2,  3], [ 4,  5,  6], [ 7,  8,  9], [10, 11, 12]])
    np.hstack((arr1, arr2))
    # array([[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]])

    # 数组拆分, [pos1, pos2] -> [[:pos1], [pos1:pos2], [pos:]]
    np.split(np.arange(9).reshape(3,3), [1, 2])
    # [array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]
    np.split(np.arange(9).reshape(3,3), [1, 2], axis=1)
    # [array([[0], [3], [6]]), array([[1], [4], [7]]), array([[2], [5], [8]])]


########################################################################
###  广播
########################################################################
def fun5():
    arr = np.random.randn(3, 3)
    """
    array([[-0.15336474,  0.28725455, -0.85035469],
       [-0.16476993, -0.65184226,  1.36339074],
       [-0.70187699, -0.35929781, -0.09595226]])
    """

    mean = arr.mean(axis=1) # 行均值
    # array([-0.23882162,  0.18225952, -0.38570902])
    arr - mean.reshape(3,1)
    """
    array([[ 0.08545689,  0.52607618, -0.61153306],
           [-0.34702945, -0.83410177,  1.18113123],
           [-0.31616797,  0.02641121,  0.28975676]])
    """


########################################################################
###  文件读写
########################################################################
# 文件读写速度非常快，1000万数据运算毫秒级
def fun6():

    arr = np.random.randn(100000,10)

    arr.tofile('./document/floats-10M.csv', sep=',', format="%.6f")

    arr = np.loadtxt('./document/floats-10M.csv', dtype=np.float, delimiter=',')

    arr *= 10
    print(arr[:10])

fun6()


def moduleNumpyArray():
    """
    ndarray, 多维同构数据

    arr =   0   1   2   3   4
            5   6   7   8   9
            ...
            90  91  92  93  94
            95  96  97  98  99
    """
    np.unique([[1, 1, 2, 3], [4,5,6,6]])
    # array([1, 2, 3, 4, 5, 6])

    np.sort([[1, 2], [4, 2]], 1)  # [[1, 2], [2, 4]], 仅对指定行排序(其它行不变), 返回副本

    arr = arr.copy()  # 深复制

    arr1 = arr.T  # 返回转置数组（浅复制）
    arr1 = arr[1:-1, 1:3]  # 切片, 位于非首尾行、第2列和第3列的部分（浅复制）
    arr1 = arr[[1, 3], :]  # 选取多行（浅复制）
    arr1 = arr[[2, 1, 0], [1, 2, 0]]  # [11, 7, 0]选取(2, 1), (1, 2), (0, 0)处的元素(深复制)

    ele = arr[0][0]  # 返回指定位置的副本
    ele = arr[0, 0]  # 同上, list类型该方式不可用

    arr1 = arr[arr > 90]  # 选取数组中所有大于90的元素, 返回一行数据-1*n型（深复制）
    arr1[arr1 > 0] = 1  # 替换数组中大于0的元素为1
    arr1 = np.where(arr > 90, 100, 0)  # 替换数组中元素大于90的为100、小于的为0（深复制）, 三元表达式
    arr1 = arr[(arr < 10) | (arr > 90)]  # 选取数组中大于10或小于90的所有元素, 1*n型(深复制)

    arr1 = np.delete(arr, range(18), axis=0)  # 返回arr去除前18行的副本
    arr1 = np.delete(arr, -1, axis=1)  # 返回arr去除最后一列的副本



    cmax = np.amax(arr, axis=0)  # 1*5, 列最大值(深复制)
    rmax = np.amax(arr, axis=1)  # 20*1, 行最大值(深复制)
    mean = np.mean(arr)  # 计算所有元素均值
    cmean = np.mean(arr, axis=0)  # 列均值
    rmean = np.mean(arr, axis=1)  # 行均值
    sum = np.sum(arr)  # 所有元素之和
    csum = np.sum(arr, 0)  # 列和
    # 不同大小数组的运算称为广播
    sub = rmax - rmean  # 两数组相同位置相减
    mul = rmax * rmean  # 两数组相同位置相乘




    np.dot([1, 2, 3], [[1], [2], [3]])  # 矩阵运算shape(1,3) * shape(3,1) = shape(1)
    np.intersect1d(arr, [1, 2, 100])  # [1, 2]返回两数组中的公共元素, 1*n型列表
    np.union1d([[2], [1], [3]], [[1]])  # [1, 2, 3]返回两数组（元素类型相同）并集
    np.union1d([1, 2, 3], [1, 4])  # [1, 2, 3, 4]
    np.in1d([[1, 2], [3, 4]], [1, 2, 4, 5])  # [True, True, False, True]返回一个数组在另一个数组中是否存在的bool型列表

    np.vstack(([1, 2], [3, 4]))  # 垂直拼接(深复制)
    np.hstack(([1, 2], [3, 4]))  # 水平拼接(深复制)

    np.exp([1, 2])  # 每个元素求e的幂次方
    np.sqrt([2, 4])  # 每个元素开根号
    np.log([1, np.e])  # 每个元素以e为底求对数, log2和10则分别以2和10为底

    from numpy.linalg import inv
    arrm = np.random.randn(5, 5)
    arrm.T.dot(arrm)  # 等价于a.T * a

    arrm = arrm.dot(inv(arrm))  # 矩阵*矩阵的逆, 并非得到单位矩阵, 可能以很小的值替代0元素
    arrm[arrm < 1e-10] = 0  # 将较小的值置0
